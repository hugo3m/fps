// Code generated by bpf2go; DO NOT EDIT.
//go:build 386 || amd64 || arm || arm64 || loong64 || mips64le || mipsle || ppc64le || riscv64

package main

import (
	"bytes"
	_ "embed"
	"fmt"
	"io"

	"github.com/cilium/ebpf"
)

type bpfCounters struct{ PlayerStatePacketsSent uint64 }

type bpfPlayerState struct {
	T    uint64
	Data [1000]uint8
}

type bpfServerStats struct {
	InputsProcessed        uint64
	PlayerStatePacketsSent uint64
}

type bpfSessionData struct{ NextInputSequence uint64 }

// loadBpf returns the embedded CollectionSpec for bpf.
func loadBpf() (*ebpf.CollectionSpec, error) {
	reader := bytes.NewReader(_BpfBytes)
	spec, err := ebpf.LoadCollectionSpecFromReader(reader)
	if err != nil {
		return nil, fmt.Errorf("can't load bpf: %w", err)
	}

	return spec, err
}

// loadBpfObjects loads bpf and converts it into a struct.
//
// The following types are suitable as obj argument:
//
//	*bpfObjects
//	*bpfPrograms
//	*bpfMaps
//
// See ebpf.CollectionSpec.LoadAndAssign documentation for details.
func loadBpfObjects(obj interface{}, opts *ebpf.CollectionOptions) error {
	spec, err := loadBpf()
	if err != nil {
		return err
	}

	return spec.LoadAndAssign(obj, opts)
}

// bpfSpecs contains maps and programs before they are loaded into the kernel.
//
// It can be passed ebpf.CollectionSpec.Assign.
type bpfSpecs struct {
	bpfProgramSpecs
	bpfMapSpecs
}

// bpfSpecs contains programs before they are loaded into the kernel.
//
// It can be passed ebpf.CollectionSpec.Assign.
type bpfProgramSpecs struct {
	ServerXdpFilter *ebpf.ProgramSpec `ebpf:"server_xdp_filter"`
}

// bpfMapSpecs contains maps before they are loaded into the kernel.
//
// It can be passed ebpf.CollectionSpec.Assign.
type bpfMapSpecs struct {
	CountersMap    *ebpf.MapSpec `ebpf:"counters_map"`
	InputBuffer0   *ebpf.MapSpec `ebpf:"input_buffer_0"`
	InputBuffer1   *ebpf.MapSpec `ebpf:"input_buffer_1"`
	InputBuffer10  *ebpf.MapSpec `ebpf:"input_buffer_10"`
	InputBuffer11  *ebpf.MapSpec `ebpf:"input_buffer_11"`
	InputBuffer12  *ebpf.MapSpec `ebpf:"input_buffer_12"`
	InputBuffer13  *ebpf.MapSpec `ebpf:"input_buffer_13"`
	InputBuffer14  *ebpf.MapSpec `ebpf:"input_buffer_14"`
	InputBuffer15  *ebpf.MapSpec `ebpf:"input_buffer_15"`
	InputBuffer2   *ebpf.MapSpec `ebpf:"input_buffer_2"`
	InputBuffer3   *ebpf.MapSpec `ebpf:"input_buffer_3"`
	InputBuffer4   *ebpf.MapSpec `ebpf:"input_buffer_4"`
	InputBuffer5   *ebpf.MapSpec `ebpf:"input_buffer_5"`
	InputBuffer6   *ebpf.MapSpec `ebpf:"input_buffer_6"`
	InputBuffer7   *ebpf.MapSpec `ebpf:"input_buffer_7"`
	InputBuffer8   *ebpf.MapSpec `ebpf:"input_buffer_8"`
	InputBuffer9   *ebpf.MapSpec `ebpf:"input_buffer_9"`
	InputBufferMap *ebpf.MapSpec `ebpf:"input_buffer_map"`
	PlayerState0   *ebpf.MapSpec `ebpf:"player_state_0"`
	PlayerState1   *ebpf.MapSpec `ebpf:"player_state_1"`
	PlayerState10  *ebpf.MapSpec `ebpf:"player_state_10"`
	PlayerState11  *ebpf.MapSpec `ebpf:"player_state_11"`
	PlayerState12  *ebpf.MapSpec `ebpf:"player_state_12"`
	PlayerState13  *ebpf.MapSpec `ebpf:"player_state_13"`
	PlayerState14  *ebpf.MapSpec `ebpf:"player_state_14"`
	PlayerState15  *ebpf.MapSpec `ebpf:"player_state_15"`
	PlayerState2   *ebpf.MapSpec `ebpf:"player_state_2"`
	PlayerState3   *ebpf.MapSpec `ebpf:"player_state_3"`
	PlayerState4   *ebpf.MapSpec `ebpf:"player_state_4"`
	PlayerState5   *ebpf.MapSpec `ebpf:"player_state_5"`
	PlayerState6   *ebpf.MapSpec `ebpf:"player_state_6"`
	PlayerState7   *ebpf.MapSpec `ebpf:"player_state_7"`
	PlayerState8   *ebpf.MapSpec `ebpf:"player_state_8"`
	PlayerState9   *ebpf.MapSpec `ebpf:"player_state_9"`
	PlayerStateMap *ebpf.MapSpec `ebpf:"player_state_map"`
	ServerStats    *ebpf.MapSpec `ebpf:"server_stats"`
	SessionMap     *ebpf.MapSpec `ebpf:"session_map"`
}

// bpfObjects contains all objects after they have been loaded into the kernel.
//
// It can be passed to loadBpfObjects or ebpf.CollectionSpec.LoadAndAssign.
type bpfObjects struct {
	bpfPrograms
	bpfMaps
}

func (o *bpfObjects) Close() error {
	return _BpfClose(
		&o.bpfPrograms,
		&o.bpfMaps,
	)
}

// bpfMaps contains all maps after they have been loaded into the kernel.
//
// It can be passed to loadBpfObjects or ebpf.CollectionSpec.LoadAndAssign.
type bpfMaps struct {
	CountersMap    *ebpf.Map `ebpf:"counters_map"`
	InputBuffer0   *ebpf.Map `ebpf:"input_buffer_0"`
	InputBuffer1   *ebpf.Map `ebpf:"input_buffer_1"`
	InputBuffer10  *ebpf.Map `ebpf:"input_buffer_10"`
	InputBuffer11  *ebpf.Map `ebpf:"input_buffer_11"`
	InputBuffer12  *ebpf.Map `ebpf:"input_buffer_12"`
	InputBuffer13  *ebpf.Map `ebpf:"input_buffer_13"`
	InputBuffer14  *ebpf.Map `ebpf:"input_buffer_14"`
	InputBuffer15  *ebpf.Map `ebpf:"input_buffer_15"`
	InputBuffer2   *ebpf.Map `ebpf:"input_buffer_2"`
	InputBuffer3   *ebpf.Map `ebpf:"input_buffer_3"`
	InputBuffer4   *ebpf.Map `ebpf:"input_buffer_4"`
	InputBuffer5   *ebpf.Map `ebpf:"input_buffer_5"`
	InputBuffer6   *ebpf.Map `ebpf:"input_buffer_6"`
	InputBuffer7   *ebpf.Map `ebpf:"input_buffer_7"`
	InputBuffer8   *ebpf.Map `ebpf:"input_buffer_8"`
	InputBuffer9   *ebpf.Map `ebpf:"input_buffer_9"`
	InputBufferMap *ebpf.Map `ebpf:"input_buffer_map"`
	PlayerState0   *ebpf.Map `ebpf:"player_state_0"`
	PlayerState1   *ebpf.Map `ebpf:"player_state_1"`
	PlayerState10  *ebpf.Map `ebpf:"player_state_10"`
	PlayerState11  *ebpf.Map `ebpf:"player_state_11"`
	PlayerState12  *ebpf.Map `ebpf:"player_state_12"`
	PlayerState13  *ebpf.Map `ebpf:"player_state_13"`
	PlayerState14  *ebpf.Map `ebpf:"player_state_14"`
	PlayerState15  *ebpf.Map `ebpf:"player_state_15"`
	PlayerState2   *ebpf.Map `ebpf:"player_state_2"`
	PlayerState3   *ebpf.Map `ebpf:"player_state_3"`
	PlayerState4   *ebpf.Map `ebpf:"player_state_4"`
	PlayerState5   *ebpf.Map `ebpf:"player_state_5"`
	PlayerState6   *ebpf.Map `ebpf:"player_state_6"`
	PlayerState7   *ebpf.Map `ebpf:"player_state_7"`
	PlayerState8   *ebpf.Map `ebpf:"player_state_8"`
	PlayerState9   *ebpf.Map `ebpf:"player_state_9"`
	PlayerStateMap *ebpf.Map `ebpf:"player_state_map"`
	ServerStats    *ebpf.Map `ebpf:"server_stats"`
	SessionMap     *ebpf.Map `ebpf:"session_map"`
}

func (m *bpfMaps) Close() error {
	return _BpfClose(
		m.CountersMap,
		m.InputBuffer0,
		m.InputBuffer1,
		m.InputBuffer10,
		m.InputBuffer11,
		m.InputBuffer12,
		m.InputBuffer13,
		m.InputBuffer14,
		m.InputBuffer15,
		m.InputBuffer2,
		m.InputBuffer3,
		m.InputBuffer4,
		m.InputBuffer5,
		m.InputBuffer6,
		m.InputBuffer7,
		m.InputBuffer8,
		m.InputBuffer9,
		m.InputBufferMap,
		m.PlayerState0,
		m.PlayerState1,
		m.PlayerState10,
		m.PlayerState11,
		m.PlayerState12,
		m.PlayerState13,
		m.PlayerState14,
		m.PlayerState15,
		m.PlayerState2,
		m.PlayerState3,
		m.PlayerState4,
		m.PlayerState5,
		m.PlayerState6,
		m.PlayerState7,
		m.PlayerState8,
		m.PlayerState9,
		m.PlayerStateMap,
		m.ServerStats,
		m.SessionMap,
	)
}

// bpfPrograms contains all programs after they have been loaded into the kernel.
//
// It can be passed to loadBpfObjects or ebpf.CollectionSpec.LoadAndAssign.
type bpfPrograms struct {
	ServerXdpFilter *ebpf.Program `ebpf:"server_xdp_filter"`
}

func (p *bpfPrograms) Close() error {
	return _BpfClose(
		p.ServerXdpFilter,
	)
}

func _BpfClose(closers ...io.Closer) error {
	for _, closer := range closers {
		if err := closer.Close(); err != nil {
			return err
		}
	}
	return nil
}

// Do not access this directly.
//
//go:embed bpf_bpfel.o
var _BpfBytes []byte
